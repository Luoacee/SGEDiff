# This file is not usedXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXimport osimport sysfrom torch.utils.data import Datasetimport lmdbfrom rdkit import Chemfrom tqdm import tqdmimport pickleimport numpy as npfrom collections import Counterimport randomfrom rdkit.Chem import BondTypefrom rdkit.Chem import HybridizationTypefrom rdkit.Chem import QEDfrom rdkit.Chem import Lipinskifrom rdkit.Chem import Descriptorsfrom rdkit.Chem import Crippenfrom utils.evaluation import sascorerfrom rdkit.Chem import Descriptorsfrom rdkit.ML.Descriptors import MoleculeDescriptorsfrom utils.unitools import MolReprrandom.seed(712)# Chemical_infoBACKBONE_ATOM = ["N", "CA", "C", "O"]BONDTYPE = {BondType.SINGLE: 1, BondType.DOUBLE: 2, BondType.TRIPLE: 3, BondType.AROMATIC: 4}HYBRIDTYPE = {HybridizationType.UNSPECIFIED:"S",              HybridizationType.S:"S", HybridizationType.SP:"SP", HybridizationType.SP2:"SP2",              HybridizationType.SP3:"SP3", HybridizationType.SP3D:"SP3D", HybridizationType.SP3D2:"SP3D2",              }AA_NAME_SYM = {    'ALA': 'A', 'CYS': 'C', 'ASP': 'D', 'GLU': 'E', 'PHE': 'F', 'GLY': 'G', 'HIS': 'H',    'ILE': 'I', 'LYS': 'K', 'LEU': 'L', 'MET': 'M', 'ASN': 'N', 'PRO': 'P', 'GLN': 'Q',    'ARG': 'R', 'SER': 'S', 'THR': 'T', 'VAL': 'V', 'TRP': 'W', 'TYR': 'Y',}prop_name = ['TPSA', 'MolLogP', 'NumHAcceptors', 'NumHDonors']des_cal = MoleculeDescriptors.MolecularDescriptorCalculator(prop_name)AA_NAME_NUMBER = {    k: i for i, k in enumerate(AA_NAME_SYM.keys())}class PocketLigandPairDataset(Dataset):    def __init__(self, ):        super().__init__()class PDBINFO_reader:    def __init__(self, path):        self.mdb_path = path        self.db = None        self.tdb = None        self.keys = None        assert os.path.exists(self.mdb_path), "MDB path is not found."    def connect_db(self):        assert self.db is None, "DB has already been opened."        self.db = lmdb.open(self.mdb_path,                            map_size=5 * (1024 * 1024 * 1024),                            create=False,                            subdir=False,                            readonly=False,                            lock=False,                            readahead=False,                            meminit=False                            )        self.get_key()    def get_key(self):        with self.db.begin(write=False) as txn:            cursor = txn.cursor()            self.keys = [i.decode() for i in cursor.iternext(values=False)]    def data_read(self):        self.connect_db()        assert len(self.keys) is not None, "Keys is not exist."        with self.db.begin(write=False) as txn:            record_assert_error = []            for p_idx, p_key in enumerate(tqdm(self.keys)):                # if pdx <= 3887:                #     continue                p_info = pickle.loads(txn.get(p_key.encode()))                # try:                protein_name = p_info['p']                protein_pocket = p_info["distance_pocket_mol"]                ligand_center_coord = p_info["ligand_center"]                ligand_mol = p_info["ligand_mol"]                desc = des_cal.CalcDescriptors(ligand_mol)                mol_qed = QED.qed(ligand_mol)                mol_sa = sascorer.compute_sa_score(ligand_mol)                mol_ha = desc[2]                mol_hd = desc[3]                mol_tpsa = desc[0]                mol_logp = desc[1]                smiles = Chem.MolToSmiles(ligand_mol)                # intact_info                interaction_cls = p_info["interaction_cls"]                # ligand_split = [int(i) for i in p_info["ligand_idx"]]                # f_intact_type = self.split_list(intact_type, ligand_split)                interaction_mapping = p_info["interaction_mapping"]                interaction_ligand_coords = p_info["ligand_interaction_coords"]                interaction_res_coords = p_info["res_interaction_coords"]                # pures_info                pures_res_idx = p_info["pures_mapping"]                assert protein_pocket is not None                # value                score_value = p_info["score"]                # except Exception as e:                #     # print("Error: ", e)                #     continue                # pures check                protein_coords = protein_pocket.GetConformer().GetPositions()                pures_idx = []                for pr in pures_res_idx:                    pr_atom = pr[0]                    pr_coords = pr[1]                    assert np.sum((protein_coords[pr_atom] - pr_coords) ** 2) ** 0.5 < 1e-4, "Pures coords error!"                    pures_idx.append(int(pr_atom))                error_detect = self.info_process(p_key, p_idx, protein_pocket,                                  ligand_mol, ligand_center_coord, interaction_cls,                                  interaction_mapping, interaction_ligand_coords, interaction_res_coords,                                  pures_idx, score_value, smiles, mol_qed, mol_sa, mol_ha, mol_hd, mol_logp, mol_tpsa)                try:                    if error_detect[0] == 1:                        record_assert_error.append("%s" % p_key)                        # with open("PLPairError.txt", "a") as F:                        #     F.write("%s: " % p_key + error_detect[1] + "\n")                except Exception as e:                    pass            print(len(record_assert_error))        self._close_db()    def __len__(self):        assert self.keys is not None, "Need connect datasets first!"        return len(self.keys)    def _close_db(self):        self.db.close()        self.tdb.close()        self.db = None    def info_process(self, *args):        raise NotImplementedError    @staticmethod    def split_list(list_, index):        split_line = []        for k, v in Counter(index).items():            split_line.append(v)        split_line_cumsum = np.cumsum(split_line)        split_line_cumsum = np.insert(split_line_cumsum, 0, 0)        split_list_ = [list_[split_line_cumsum[i]:split_line_cumsum[i + 1]]                       for i in range(len(split_line_cumsum)) if i < len(split_line_cumsum) - 1]        assert split_line == [len(i) for i in split_list_], "split_list error"        return split_list_class TrainingDataCollate(PDBINFO_reader):    def __init__(self, path):        super().__init__(path)        self.data_dir = os.path.join(*path.split("/")[:-1], "DatasetCollateNH_M.mdb")        self.unimol_rep = MolRepr(data_type='molecule', remove_hs=False)        self.tdb = lmdb.open(self.data_dir,                             map_size=10 * (1024 * 1024 * 1024),                             create=False,                             subdir=False,                             readonly=False,                             lock=False,                             readahead=False,                             meminit=False                             )    @property    def random_idx(self):        assert len(self.keys) is not None, "Keys is not exist."        data_n = len(self.keys)        random_sequence = list(range(data_n))        random.shuffle(random_sequence)        return random_sequence    def info_process(self, p_key, p_idx, protein_mol, ligand_mol, ligand_center, interaction_cls,                     interaction_mapping, interaction_ligand_coords, interaction_res_coords, pures, vina_score,smiles,                     mol_qed, mol_sa, mol_ha, mol_hd, mol_logp, mol_tpsa):        wt_info = dict()        wt_key = p_key        # print(wt_key)        wt_info["name"] = p_key        wt_info["datasets"] = self.train_test_marker(p_idx)        wt_info["ligand_center"] = ligand_center        wt_info["score"] = vina_score        wt_info["qed"] = mol_qed        wt_info["sa"] = mol_sa        wt_info["ha"] = mol_ha        wt_info["hd"] = mol_hd        wt_info["logp"] = mol_logp        wt_info["tpsa"] = mol_tpsa        print(smiles)        wt_info["smiles"] = self.unimol_rep.get_repr([smiles], return_atomic_reprs=False)        valid_interaction = []  # S -> E, cls, S_coords, E_coords        protein_mol_coords = protein_mol.GetConformer().GetPositions()        ligand_mol_coords = ligand_mol.GetConformer().GetPositions()        for int_idx in range(len(interaction_mapping)):            intact = interaction_mapping[int_idx]                # check protein            if len(intact[0]) == 1:                assert np.sum((interaction_res_coords[int_idx] - protein_mol_coords[intact[0][0]])**2)**0.5 < 1e-1            # check ligand            if len(intact[1]) == 1:                # print(np.sum((interaction_ligand_coords[int_idx] - ligand_mol_coords[intact[1][0]])**2)**0.5)                assert np.sum((interaction_ligand_coords[int_idx] - ligand_mol_coords[intact[1][0]])**2)**0.5 < 1e-1            valid_interaction.append((intact, interaction_cls[int_idx],                                      interaction_res_coords[int_idx], interaction_ligand_coords[int_idx]))        # except Exception as e:        #     return [1, str(e)]        wt_info["interaction"] = valid_interaction        pro_atom_class, pro_backbone,  pro_res_names, pro_hybridization = [], [], [], []        # pro_aromaticity_h = []        pro_aromaticity = []        pro_bond_class, pro_bond_idx = [], []        pro_atom_coords = []        error_marker = False        for adx, atom in enumerate(protein_mol.GetAtoms()):            # if atom.GetAtomicNum() == 1:            #     continue            # else:            atom_symbol = atom.GetAtomicNum()            atom_res_name = atom.GetPDBResidueInfo().GetResidueName()            if atom_res_name not in list(AA_NAME_SYM.keys()):                error_marker = True                break            pro_res_names.append(AA_NAME_NUMBER[atom_res_name])            if atom.GetPDBResidueInfo().GetName().rstrip(" ").lstrip(" ") in BACKBONE_ATOM:                pro_backbone.append(1)            else:                pro_backbone.append(0)            pro_atom_class.append(atom_symbol)            atom_aromatic = atom.GetIsAromatic()            pro_aromaticity.append(atom_aromatic)            # pro_aromaticity_h.append(atom_aromatic)            pro_atom_coords.append(protein_mol_coords[adx])        if error_marker:            return [1, "ErrorResName"]        try:            assert len(pro_backbone) == len(pro_atom_class), "%s, %s" % (len(pro_backbone), len(pro_atom_class))            assert len(pro_backbone) == len(set([str(i) for i in np.array(pro_atom_coords).tolist()]))            assert len(pro_backbone) == len(pro_atom_coords)        except Exception as e:            return [1, str(e)]        for bond in protein_mol.GetBonds():            pro_bond_class.append(BONDTYPE[bond.GetBondType()])            pro_bond_idx.append((bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()))        wt_info["protein_atom_class"] = pro_atom_class        wt_info["protein_atom_is_backbone"] = pro_backbone        wt_info["protein_atom_aromatic"] = pro_aromaticity        # wt_info["protein_atom_aromatic_h"] = pro_aromaticity_h        wt_info["protein_atom_coords"] = pro_atom_coords        # wt_info["protein_atom_hybridization"] = pro_hybridization        wt_info["protein_atom_res_name"] = pro_res_names        wt_info["protein_bond_class"] = pro_bond_class        wt_info["protein_bond_idx"] = pro_bond_idx        lig_atom_class, lig_aromaticity, lig_hybridization = [], [], []        lig_bond_class, lig_bond_idx = [], []        lig_atom_coords = []        for adx, atom in enumerate(ligand_mol.GetAtoms()):            atom_symbol = atom.GetAtomicNum()            lig_atom_class.append(atom_symbol)            atom_aromatic = atom.GetIsAromatic()            lig_aromaticity.append(atom_aromatic)            lig_atom_coords.append(ligand_mol_coords[adx])            atom_sp = atom.GetHybridization()            lig_hybridization.append(HYBRIDTYPE[atom_sp])        for bond in ligand_mol.GetBonds():            lig_bond_class.append(BONDTYPE[bond.GetBondType()])            lig_bond_idx.append((bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()))        try:            assert len(lig_atom_class) == len(lig_aromaticity), "%s, %s" % (len(lig_atom_class), len(lig_aromaticity))            assert len(lig_hybridization) == len(lig_aromaticity), "%s, %s" % (len(lig_atom_class), len(lig_aromaticity))        except Exception as e:            return [1, str(e)]        wt_info["ligand_atom_class"] = lig_atom_class        wt_info["ligand_atom_aromatic"] = lig_aromaticity        wt_info["ligand_atom_coords"] = lig_atom_coords        wt_info["ligand_atom_hybridization"] = lig_hybridization        wt_info["ligand_bond_class"] = lig_bond_class        wt_info["ligand_bond_idx"] = lig_bond_idx        wt_info["pures_idx"] = pures        # print(np.array(wt_info["protein_atom_coords"]))        # print(np.array(wt_info["pures_idx"]))        if len(wt_info["pures_idx"]) == 0:            return [1, "pures None"]        if len(wt_info["interaction"]) == 0:            return [1, "interaction None"]        # print(np.array(wt_info["protein_atom_coords"]).shape)        # print(np.array(wt_info["pures_idx"]))        # test = np.array(wt_info["protein_atom_coords"])[np.array(wt_info["pures_idx"])]        with self.tdb.begin(write=True) as txn:            txn.put(wt_key.encode(), pickle.dumps(wt_info))        # all_keys = wt_info.keys()        # for k in all_keys: # 打印测试        #     try:        #         print(k, len(wt_info[k]))        #     except:        #         print(k)        #     print(wt_info[k])        #     print()        # exit()    def train_test_marker(self, idx):        split_num = int(len(self.keys) * 0.99)        if idx in self.random_idx[:split_num]:            return "train"        else:            return "test"